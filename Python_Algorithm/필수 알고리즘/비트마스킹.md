## 비트마스킹

### 비트마스킹의 장점

- 간결
- 빠름
- 메모리

True False True 를 101 로 표기하는 것..

---

### 비트 연산

1. AND &

   - 둘다 1이면 1

     ```PYTHON
     bin(0b1010 & 0b1101)
     >>> 0b1010
     ```

2. OR |

   - 둘 중 하나라도 1이면 1

     ```python
     bin(0b1010 & 0b1101)
     >>> 0b1111
     ```

3. XOR ^

   - 둘이 서로 다르면 1

     ```python
     bin(0b1010 & 0b1101)
     >>> 0b0111
     ```

4. SHIFT >> <<

   - a << b : a의 비트를 b칸만큼 왼쪽으로 옮김

     ```python
     bin(0b0010 << 2)
     >>> 0b1000
     
     bin(0b1100 >> 2)
     >>> 0b11
     
     bin(0b1010 >> 3)
     >>> 0b1
     
     bin(0b1100 << 2)
     >>> 0b110000 #중요
     ```

5. NOT ~

   - -(x+1) 을 반환

     ```python
     bin(~0b1010)
     # -(0b1010 + 1)
     # -(0b1011)
     >>> -0b1011
     ```

---

## 문제 풀때 사용하는 것들

```python
#중요
bin(1 << 1)
>>> 0b10

bin(1 << 2)
>>> 0b100

bin(1 << n)
>>> 0b1(0 : n개)

# 응용

# 0b0010 을 0b1010 으로 바꾸고 싶다.
bin(0b0010 | (1 << 3))
>>> 0b1010

# 0b1111 을 0b1011 으로
bin(0b1111 ^ (1 << 2))
또는
bin(0b1111 & ~(1 << 2))
```

---

## 비트마스킹 활용 dp 문제

https://www.acmicpc.net/problem/1480

12865번 문제와 비슷한 느낌..

모든 경우의 수를 해봐야 한다.