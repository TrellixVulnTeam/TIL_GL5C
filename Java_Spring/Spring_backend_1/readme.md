## Intro

- 모든 웹 기술은 HTTP 기반이므로
- HTTP 기본 지식을 알고 있어야 한다.
- 자바 기반 백엔드 기술의 역사가 길기 때문에 학습하기 어렵다.
- 스프링 MVC가 제공하는 기능이 너무 방대하기 때문에 배울 내용이 많다.
- 핵심 구조를 파악하기 힘들다.

---

## Web Application

- 웹이란 모두 HTTP 기반으로 동작한다.
- 웹 세상에서는 모든 것이 HTTP이다.
  - 거의 모든 형태의 데이터를 주고 받을 수 있다.
- 웹 서버
  - 정적 자원을 제공한다.
  - NGINX, APACHE
- WAS
  - 웹 서버의 기능을 대부분 포함하고 있다.
  - 코드를 실행해서 로직을 수행할 수 있다.
    - 즉, 동적 페이지 처리 가능
    - 서블릿, JSP, Spring MVC 등이 was에서 동작한다.
  - Tomcat
  - 자바 진영에서는 보통 서블릿 컨테이너 기능을 제공하면 WAS라고 부른다.
- 웹 시스템
  - 웹 시스템은 WAS, DB 만으로도 구성이 가능하다.
  - 하지만 하나의 WAS가 너무 많은 역할을 담당하면 서버 과부하가 우려되기 때문에
  - 앞 쪽에 웹 서버를 따로 두고, was를 여러대 둔다. (was에서는 동적 처리만 담당하도록)
  - 이런 식의 구성은, 정적 리소스 요청이 많아지면 웹 서버를 증가시키고, 동적 리소스 요청이 많아지면 was를 증가시키면 된다는 장점이 있다.

---

## Servlet

- 서버에서 요청 들어온 HTTP 메시지를 파싱해서 읽어서 해석을 한 뒤, 비즈니스 로직 실행을 한 뒤 HTTP 응답 메세지를 작성해서 전달한다.
- 이 과정에서 서블릿을 사용하면, 비즈니스 로직 부분에만 개발자가 집중할 수 있게된다.
- 개발자는 TCP/IP 연결, 파싱해서 해석하고, 멀티쓰레딩 등을 고민할 필요가 없어졌다.
- 즉, HTTP 요청 시
  - WAS가 Request, Response 객체를 새로 만들어서 서블릿 객체를 호출한다.
  - 개발자는 Request 객체에서 HTTP 요청 정보를 편하게 꺼내서 사용할 수 있다.
  - 또, Response 객체에 HTTP 응답 정보를 편하게 입력해서 집어 넣을 수 있다.
  - WAS는 Response 객체의 내용으로 HTTP 응답 메세지를 생성한다.
- 서블릿 컨테이너란 무엇인가?
  - WAS안에는 서블릿 컨테이너가 있는데, 여기 안에서 서블릿 객체를 알아서 생성해주고, 생명주기도 관리해주고, 호출도 해준다.
  - 톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 한다.
  - 대부분 서블릿 객체는 싱글톤으로 관리한다.
  - 서블릿 객체는 서블릿 컨테이너 종료시 함께 종료된다.
  - 서블릿은 멀티 쓰레드 처리를 지원해준다.
- @ServletComponentScan
  - 하위 패키지를 다 뒤져서 서블릿을 찾아서 자동으로 서블릿 등록해준다.
- 서블릿은 인터페이스다.
  - 각 WAS(톰캣)들이 스펙에 맞게 구현하고 있음
- HTTP 요청 **메세지를 편리하게 사용할 수 있도록** WAS는 HttpServletRequest라는 객체에 요청 메세지를 담아서 우리에게 제공해준다.
  - 이거 말고도 여러 편리한 기능을 제공하는데
  - http 요청이 끝날 때 까지 유지되는 임시 저장소 기능을 제공해준다.
    - 저장: request.setAttribute(name, value)
    - 조회: request.getAttribute(name)
  - 세션 관리 기능도 해준다.
    - request.getSession(create: true)
- HTTP 요청 메세지를 통해서 클라이언트에서 서버로 데이터를 전달하는 방법
  - GET - 쿼리 파라미터
    - 메시지 바디 없이 url 쿼리 파라미터에 데이터를 포함해서 전달
    - 검색, 필터, 페이징 등에서 많이 사용
  - POST
    - 컨텐트 타입 정보를 같이 전달해야함 (메세지 바디의 데이터 형식)
    - 메시지 바디에 쿼리 파라미터 형식으로 전달 (HTML Form, (폼데이터는 포스트만 가능))
    - 메세지 바디에 데이터를 직접 담아서 요청 (api에서 주로 사용, 형식은 주로 json)
    - 가입, 주문 등
    - application/x-www-form-urlencoded 형식은 메세지 바디로 보내긴 하지만 파라미터 형식으로 전달이기 때문에
      - 서버 받는 입장에선 똑같으므로
      - GET처럼 requset.getParameter() 사용하면 된다 그냥
    - JSON 형식
      - 자바 객체로 사용하려면 클래스 하나 만들어서 파싱
      - objectMapper.readValue 사용
- HTTP 응답 메세지
  - response.setHeader 등을 이용해서 작성 가능
  - 텍스트 응답, HTML 응답, Json 응답 여러가지 경우가 있음
- 서블릿과 자바 코드만으로도 동적으로 원하는 HTML을 만들 수 있지만, 너무 복잡하고 비효율적
- 따라서 HTML안에 동적 부분만 자바코드로 입력할 수 있도록 템플릿 엔진이라는 것이 등장
- JSP, Thymeleaf 등등
- 

---

## 동시요청과 멀티 쓰레드

- 서블릿을 누가 호출하는가 ?
  - 쓰레드
- 자바의 main 메서드를 실행하면 main이라는 이름의 thread가 실행된다.
- thread는 한 번에 하나의 코드만 수행한다.
- 동시 처리가 필요하다면 멀티쓰레드가 필요하다.
- 그럼 요청이 하나 들어올 때마다 쓰레드 생성하면 되느냐?
  - 쓰레드 생성 비용이 비싸기 때문에 응답 속도가 늦어질 수 있다.
  - 컨텍스트 스위칭이 잦아져서 성능에 문제가 생긴다.
  - 쓰레드 생성에 제한이 없기 때문에 요청이 너무 많으면, CPU, 메모리에 문제가 있어서 서버가 죽을 수도 있다.
- 그럼 어떡하라고;
- 쓰레드 풀이라는 것을 이용
  - 요청 마다 쓰레드 생성하는 것의 단점을 보완한다.
  - 필요한 쓰레드를 쓰레드 풀에 보관하고 관리한다.
  - 쓰레드 풀에 생성 가능한 쓰레드의 최대치를 관리할 수 있다. (톰캣은 기본 200개)
  - 쓰레드가 필요하면, 쓰레드 풀에서 꺼내서 사용하고 반납
  - 쓰레드 풀에 있는게 모두 사용중이면, 거절하거나 대기하도록 설정이 가능하다.
  - 장점
    - 쓰레드 생성, 종료 비용 절약, 응답시간 향상
    - 쓰레드 생성의 최대치가 있어서, 많은 요청이 들어와도 기존 처리 중인 요청은 안전하게 처리가 가능
- 실무에서의 쓰레드 풀
  - 최대 쓰레드 수를 너무 낮게 설정하면
    - 동시 요청이 많을 시, 자원은 여유롭게 놀고, 응답이 지연된다.
  - 최대 쓰레드 수를 너무 높게 설정하면
    - 동시 요청이 많을 시, cpu와 메모리 자원 임계점 초과로 서버가 다운된다.
  - 최적 값을 찾는 것이 중요
    - 장애가 발생한다면 클라우드 환경이라면 서버를 먼저 늘리자.
    - 실제 서비스와 유사하게 성능 테스트를 시도하여 적정 수를 찾는다.
- 중요한 것은 WAS가 멀티 쓰레드 환경을 지원해준다.
  - 개발자가 따로 멀티 쓰레드 관련 코드를 신경쓰지 않아도 된다.
  - 하지만 싱글톤 객체(서블릿, 스프링 빈)는 주의해서 사용해야 한다.

---

## HTTP API, SSR, CSR

- HTTP API
  - 주로 json 방식 사용
  - 데이터만 주고 받을 때 사용
  - 서버끼리 통신할 때 주로 사용
  - 데이터를 받아서 화면을 구현하려고 할 때 사용
- SSR
  - 서버 사이드 렌더링
  - HTML 최종 결과물을 서버 사이드에서 만들어서 웹 브라우저로 전달
  - jsp, thymeleaf 등의 기술
- CSR
  - 클라이언트 사이드 렌더링
  - 주로 계속적으로 동적인 화면에 사용
  - 지도처럼 부분부분 화면이 변할 때
  - HTML 결과를 자바스크립트를 사용해서 웹 브라우저에서 동적으로 생성
    - 먼저 클라이언트에서 HTML 요청을 하면 서버는 자바스크립트 링크를 넘겨준다.
    - 다시 자바스크립트 파일을 요청한다.
    - 필요한 데이터도 서버에 요청한다.
    - 필요한 리소스를 다 받았으면 웹 브라우저는 HTML결과를 렌더링 한다.

---

## 자바 웹 기술의 역사

- 서블릿을 이용하여 HTML을 만들어내기가 어렵다.
  - 자바 코드 안에 HTML을 작성해야 하기 때문..
- 그래서 JSP라는게 나옴
  - HTML 안에 자바 코드를 사용할 수 있어서 작성이 편리해졌지만, 너무 많은 역할을 담당하게 되어 유지보수가 어렵다.
- 그래서 MVC 패턴이라는게 나왔다.
  - 서블릿, JSP를 조합하여 역할을 나누어서 개발했다.
- 이런 개발 방식이 정형화 되다보니, 프레임워크를 만들기 시작했다.
  - MVC패턴을 자동화 해주고, 복잡한 웹 기술을 편리하게 사용할 수 있는 다양한 기능을 지원해주게 되었다.
- 어노테이션 기반의 스프링 MVC가 등장했다.
- 스프링 부트가 등장했다.
  - 스프링 부트는 WAS를 내장하고 있다.
  - 과거에는 서버에 WAS를 설치하고, war파일을 만들어서 그곳에 배포했는데
  - 스프링 부트를 이용하면 빌드 할때 Jar파일에 서버가 포함되어 있어서 배포가 단순화 되었다.

---

## JSP

- jsp 사용하려면 라이브러리 추가해야함

- ```java
  implementation 'org.apache.tomcat.embed:tomcat-embed-jasper'
  implementation 'javax.servlet:jstl'
  ```

- JSP는 서버 내부에서 서블릿으로 변환 된다.

- 그래서 서블릿과 거의 비슷하지만 누가 주체이냐 차이이다.

  - 서블릿은 자바코드가 주체고 html을 중간중간 쓴다.
  - JSP는 HTML 중간중간에 자바코드를 넣는다.

- <%@ page import="hello.servlet.domain.member.MemberRepository" %>

  - 자바의 import 문과 같다.

- <% ~~ %> 

  - 이 부분에는 자바 코드를 입력할 수 있다.

- <%= ~~ %>

  - 이 부분에는 자바 코드를 출력할 수 있다.

- 하지만 JSP의 한계는 한 JSP 파일이 너무 많은 역할을 한다.

  - JAVA 코드, 데이터를 조회하는 리포지토리 등등 다양한 코드 등..

- 비즈니스 로직은 서블릿 처럼 다른곳에서 처리하고, JSP는 목적에 맞게 HTML로 화면(View)을 그리는 일에 집중하도록 하기 위해 MVC 패턴이 등장했다.

---

## MVC 패턴

- 하나의 파일이 너무 많은 역할을 하게되면, 유지보수가 어려워진다.
- view 쪽 수정하는 일과, 비즈니스 로직을 수정하는 일은 각각 다르게 발생할 가능성이 높고 서로에게 영향을 주지 않지만,
  - 즉, 변경 주기가 다르지만, 그것들을 하나의 코드로 관리하는 것은 유지보수하기 좋지 않다.
- 따라서 모델, 뷰 컨트롤러 세 영역으로 역할을 나눈다.
- 모델 : 뷰에 출력할 데이터를 담아둔다.
- 뷰 : 모델에 담겨있는 데이터를 사용해서 화면에 그린다. (HTML 생성)
- 컨트롤러 : HTTP 요청을 받아서 비즈니스 로직을 실행하고, 뷰에 전달할 결과를 조회하여 모델에 담는다.
- 일반적으로 비즈니스 로직은 Service 계층을 별도로 만들어서 처리한다.
  - 서비스 계층에 메서드를 짜고, 컨트롤러에서는 http 요청 검증 후 메서드만 호출.
  - 컨트롤러에 비즈니스 로직도 넣어버리면, 또 너무 많은 역할을 담당하게 됨.
- 
