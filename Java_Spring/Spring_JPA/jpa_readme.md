- https://start.spring.io

- Gradle

- 그룹과 아티팩트 설정

- dependency 설정

  - spring web : 아파치 톰캣
  - thymeleaf
  - spring data jpa
  - h2 database
  - lombok
  - validation

- 환경설정

  - plugin lombok
  - enable annotation processing

- jsp 보다는 thymeleaf

  - 서버사이드 템플릿엔진

- 프로젝트 빌드하고 띄우는법

  - ./gradlew clean build
  - cd libs
  - java -jar 파일명
  - 맥북 포트 pid 확인
    - lsof -i :8080

- jpa 임베디드 protected // 내장타입

- 영속성 컨텍스트

- 트랜잭션, transactional

- dip, solid

- 커밋될때 인서트문

- 

- ```
  RequiredArgsConstructor
  ```

- 
- **엔티티는 핵심 비즈니스 로직만 가지고 있고****,** **화면을 위한 로직은 없어야 한다**.
  - 발리데이션 그런거
- dto
- 변경감지와 병합
- 변경감지 - 더티체킹
- 식별자가 디비에 이미 존재하는 객체..? 준영속 엔티티라고 함
- new로 생성하긴 햇지만 예를들어 id를 원래 있던애로 설정하면 준영속
  - 이런애들은 jpa가 관리를 안함
  - 어떻게 업데이트를 치느냐...
    - 준영속이어도 변경감지 쓰기
    - merge 쓰기d
- 변경감지 쓰는법?
  - 해당 id를 뉴하지말고 가져와
  - 트랜잭셔널 어노붙으면 커밋을함
    - 커밋을하면 jpa가 플러시를날림
      - 영속성콘텍스트에 잇는 엔티티중에 변경된게 먼지 찾는다
      - 동기화과정
      - 업데이트쳐버림
- 병합은 준영속 > 영속으로 바꾸기
  - 걍 merge를 쓰면 위에꺼처럼 ㅇㅇ 변경해주는거
  - 근데 병합을 쓰면 모든 속성을 업뎃쳐야해서;; 발리데이션 그런거 null 값 등 조심
  - 그래서 일부속성만할꺼면 일일히 변경감지 ㅇㅇ
  - 머지는 잘 안씀; ㅋ
- 컨트롤러에서는 식별자만 넘겨주고
  - 서비스 -> 트랜잭션 안에서 엔티티 조회하고 그렇게 한다.
  - 트랜잭션없이 밖에서 뉴해서 생성하고 그러면 jpa랑 관계없는놈이 오기때문에..
- source bin/h2.sh  디비실행
- 스프링빈

---

- RequiredArgsConstructor

- api 만들때 엔티티를 파라미터로 받지말라 외부노출 ㄴㄴ

- 엔티티바뀌면 api 스펙 변하니까

- 별도 DTO를 파라미터로 받아야한다.

- dto에는 그냥 어노테이션 막 쓰기. 대충..

  - AllArgsConstructor

- 수정할때는 웬만하면 void로 업뎃치고 id 정도만 반환.. 객체전체말고

- 겟방식으로 디비조회할때 다보이면 안대지

  - 엔티티 속성중에 @JsonIgnore 붙이면 안보이게할수잇긴한데 이건좀;; ㄴㄴ
  - 그럼어카냐
  - API 응답 스펙에 맞추어 별도의 DTO를 반환한다.
  - 그런경우도 잇다. 예를들어 회원조회를하고 그 회원이 몇명인지도 써주면 좋겟는데
  - 그러면 스펙이 깨진다.. 그래서 엔티티자체로 하면 ㄴㄴ

- 주문 Api

  - 양방향 엔티티 있으면 한쪽에 JsonIgnore 넣으라 @@@중요
  - 무한루프방지를 위해서
  - 근데 이것도 에바다 그니까 걍 엔티티직접 ㄴㄴ
  - 엔티티직접하면 필요없는 엔티티속성의 쿼리까지 나간다.
  - 쓸데없는거까지 json으로 나가면;;
  - 꼭 필요한거만 노출하도록 dto 하는게 정석

- 항상 지연로딩을 사용하라. LAZY에 대해서 더 공부

- 즉시로딩 해노면 걍 필요없느 ㄴ테이블도 끌꼬와버림성능튜닝에문제

- 필요하면 페치조인쓰면댐

- 주문 API 디티오

  - 문제점은 각 주문마다 조인을 두번해서 쿼리가
  - 한주문마다... 다 날림
  - 영속성 컨텍스트에 없으면 쿼리를 날려서 가져와야한다.
  - 이런경우 패치조인으로 최적화

- 더최적화?

  - JPA에서DTO를 바로 조회
  - 엔티티조회 > dto변환 과정 없이.. 하면 최적화 가능
  - 셀렉트절에서 필요한데이터만 가져오도록..
  - 재사용성이 부족하다는점이있지ㅏㅁㄴ 성능적으로는 좀더 좋다.
    - 근데 글케마니안남 셀렉트컬럼 몇개 추가한다해서;;
  - 코드도 더 지저분 jpql 짜는것..
  - API 스펙이 리포지토리에 들어간다.
    - 즉 API스펙이 바뀌면 리포지토리도 뜯어고쳐야할수..
    - 리포지토리는 엔티티 조회할때쓰는거다;
    - 음 약간 그래서 리포지토리 하위에 별도폴더를 만들어서하자 할거면
  - (의존관계는 한방향으로 흘러야한다)

- 엔티티를 DTO로 변환하거나, DTO로 바로 조회하는 두가지 방법은 각각 장단점이 있다. 둘중 상황에 따라서 더 나은 방법을 선택하면 된다. 엔티티로 조회하면 리포지토리 재사용성도 좋고, 개발도 단순해진다.

- 일대다 관계 를 컬렉션조회라하는데 이걸 최적화하는법

  - 원투원 원투매니는 펫치조인하면댐

  - 컬렉션페치조인은 ㄷ ㅓㅏ생각할게 많다

  - 오더하나에 오더아이템이 여러개라서

  - 둘이 조인시켜서 쿼리를 보내면

  - row가 오더 아이템만큼 생긴다.

  - 이게 문제다. 

  -  distinct 쓰면되긴함

  - 근데 일대 다에서 페치조인쓰면 페이징처리르 못함.

    - 절대 ㄴㄴ
    - 일 대 다 에서 일 을 기준으로 페이징해야하는데
    - 디비에서는 조인하면 다 를ㄱ준으로 row생성되기땜에 오류가생기는것

  - 페치조인 페이징까지하는법

    - ?대1 관계는 모두 페치조인을 건다. ㄱㅊ다 로우가 뻥튀기되지않는다.

    - 컬렉션, ?대다 관계는 지연로딩으로 조회한다.

    - 그리고 yml 파일에서 최적화옵션을 넣는거임

    - ```
      default_batch_fetch_size: 1000
      ```

    - 저 옵션을 넣으면 디비중에서 내가 원하는 order_id를 포린키로 갖고잇는

    - 아이템들을 모두 한번에 가져옴

    - 예륻를면 1번,4번 오더 관련상품만 ..

    - where orderitems.order_id in (1,4) 이런식

    - 저 위에 베치사이즈가 인 쿼리 갯수를 몇개로할꺼냐

    - 그럼 걍 최대한 많이넣고 한번에 땡겨오는게 좋은거아니냐?

      - 순간부하증가라는 측면이잇긴하지만
      - 어쨋든 다 가져오긴 하는거라서;; 순간부하 견딜수잇는만큼설정하믄댐

      

- 정리합시다

  - 엔티티조회 그대로 반환?
    - 스펙문제.. ㄴㄴ절대 ㄴㄴ
  - 엔티티 조회후 dto변환
  - 페치조인으로 쿼리수를 최적화
  - 컬렉션 페이징 가능하도록 만들기
  - 여기서부턴좀...
  - JPA에서 DTO직접조회 4버전 5버전
    - 이게뭔장점?
    - 엔티티조회후 dto변환 방식으로 해결안될때 해라
  - 성능최적화와 코드복잡도 사이에서 고민..

- 오픈 세션 인 뷰

  - OSIV

- 동적쿼리는 querydsl

- 타임리프나 jsp 써서 하나요

- 아니면 순수 api만 개발

- 
