- IP 인터넷 프로토콜
  - 패킷이라는 통신단위로 데이터를 보냄.
  - ip패킷에는 규칙이잇다.
  - 한계
    - 패킷을받을 대상이 없거나 서비스불능이어도 패킷은 전송
    - 중간에 패킷이 사라지거나 순서대로 안올수도
    - 같은 아이피를 사용..
  - 한계를 해결하기위해
- TCP/IP
- 프로토콜 계층
  - 애플리케이션(소켓라이브러리) > TCP/udp/ip (운영체제) > 네트워크 인터페이스(랜카드)
    - tcp udp는 ip바로 위 꼐층에 잇다.
  - 전달전달전달 해서 랜카드로 보냄
- TCP
  - 트랜스미션 컨트롤 프로토콜
  - TCP로 감싸면
  - 출발지 목적지 포트, 전송제어, 순서, 검증 에 대한 정보들이 더들어감
  - 연결 지향. 연결이되어잇어야 보낸다.
    - 3way handshake 접속요청 > 요청수락,나도접속요청 > 요청수락
  - 데이터 전달을 보증해준다.
    - 데이터를 보내면, 잘 받았다고 응답해줌
  - 순서도 보장해준다.
    - 순서가 안맞으면 다시보내라고 요청함.
  - 신뢰할수잇고, 대부분 tcp 사용
- udp
  - 기능이 거의 없음.
    - tcp특징 하나도없지만
    - 단순하고 빠르고
    - ip랑 거의 같은데 port랑 데이터 검증 정도기능만 잇음.
- tcp/ip 패킷에는 출발지목적지 ip port 가잇는것 그래서 각 프로세스마다.
  - 아파트 몇동몇호
- 포트번호 0~65535 할당가능
  - 0~1023 거의 쓰고잇어서 사용 ㄴㄴ
- DNS
  - ip는 기억하기 어렵고, 바뀔수잇다.
    - 전송을어케해;;
  - 도메인네임시스템
  - 도메인명을 등록하고, 그에 대한 ip주소를 등록가능
  - 키밸류느낌이지
- URI 유니폼 리소스 아이덴티파이어
  - uri 안에 url urn 로케이터 네임 잇는것
  - url 리소스가 잇는 위치를 지정
  - path, query
- 네트워크 흐름
  - DNS 조회, 포트정보 조회
  - http 요청 메세지 생성
  - 소켓라이브러리 > TCPIP연결하고 패킷생성해서 전달
  - 응답해서 데이터를 주면
  - 웹브라우저가 데이터를 받아서 렌더링해서 보여진다
- http 메세지로 모든형태의 데이터 전송가능
- 클라이언트 - 서버 구조
  - 요청과 응답의 구조
- Stateful, Stateless
  - 무상태 프로토콜
  - 서버가 클라이언트의 상태를 보존하지않는다. 기억하지않는다.
  - 클라이언트가 추가 데이터를 전송해줘야할수잇다
  - 무상태를 지향한다. 중요~
  - 응답서버를 쉽게 바꿀수잇다. 클라이언트꺼를 뭘 기억할필요없으니.
  - 확장이 유리하다
  - 근데 한계가잇다
    - 로그인같은거는 상태를 유지해야한다..
    - 일반적으로 쿠키, 서버 세션 사용
    - ㅇ무튼 상태유지는 최소한으롬나 사용
- 비연결성을 유지해야함
  - 서버자원을 효율적으로 사용가능
  - 3way hand쉐이크 연결 시간하는데 걸림
  - 근데 1개 html에 5개의 사진잇다 
  - 이거도 하나씩 핸드쉐이크해야하는데
  - 지속연결을 통해서 유지하면 해겨가능
- 선착순이벤트
  - 수만명 동시요청;;
- 중요HTTP메시지
  - 요청메세지
    - 스타트라인
      - 리퀘스트라인 이라고도함
        - 방식 타겟(절대경로) HTTP버전 CRLF
    - 헤더
      - 필드네임: 벨류
      - HTTP전송에 필요한 모든 부가정보가 들어잇다
      - 메시지바디내용,크기, 압축,인증, 요청클라이언트정보, 캐시정보 등
    - 공백라인CRLF
    - 메세지바디
  - 응답메시지
    - 스테이터스라인
      - http버전 상태코드
- 정리
  - HTTP 메시지로 모든데이터를 전송한다
  - 클라이언ㅌ - 서버 구조
  - 스테이트리스
- URI 설계 시
  - 자원을 중심으로 설계
  - 복수형, 명사작성
  - 동사를 피해라
- 클라에서 서버로 데이터보낼때
  - 쿼리파라미터로 보내거나 겟방식 검색필터
  - 메시지바디로 전송
    - 헤더에 컨텐트타입 줘야함
    - 예를들어 폼으로 보내고싶으면 Content-Type: application/x-www-form-urlencoded
- HTTP 헤더 중요
  - 표현 : 실제 데이터
  - 표현헤더는 표현데이터를 해석할수잇는 정보를 제공
    - 데이터유형 압축정보 데이터길이 등등
  - 컨텐츠 네고시에이션
    - 클라이언트가 선호하는 표현을 요청하는것
    - Accept-Language: ko
    - 가능하면 한국어좀주세여
    - 근데 없을수도잇고 다른언어가잇을수잇으니
    - 우선수위가 잇으면 좋다
    - q값으로 표현 0에서 1사이
  - 전송 방식
    - 단순전송
    - 압축전송
    - 분할전송
      - 마지막은 0바이트 \r\n 보내면 된다.
      - 컨텐트렝스를 넣으면안된다.
      - 매 줄마다 바이트수 어차피 적으니께
    - 범위전송
      - 어디서부터 어디까지.
      - 컨텐츠 레인지
  - 일반정보헤더
    - referrer
      - 이전 요청이 어디서 들어온건지.. 그니까 이전페이지
      - 들어오게된 경로를 알게됨 유입경로분석가능
    - 유저에이전트
      - 웹브라우저 정보
      - 어떤 종류에서 장애가 발생하는지 파악가능
    - 서버
      - 내 요청을 만들어준 서버
      - 아파치 엔진엑스
      - 응답에서사용
    - date
      - 응답에 사용
  - 특별한 정보헤더
    - 호스트 헤더
      - 요청할때 필수로 사용
      - ip통신만하면 어느 도메인으로 가야할지모른다. 그래서 무조건 느라
    - location헤더
      - 300번대 응답 결과에 location 헤더가 잇으면 글로 자동이동함
    - 인증헤더
      - Authorization : 클라이언트 인증정보를 서버에 전달할수잇다.
  - 쿠키의 매커니즘
    - set-cookie 서버에서 클라로 쿠키 응답
    - coockie 클라이언트가 서버에서 받은 쿠키를 저장하고 http요청시 서버에 보냄
    - 우리컴터에 폴더가잇음;;(웹브라우저를통해) 쿠키저장소
    - 이걸 통해 상태유지가 가능
    - 모든요청에 사용자정보를 주면 비효율적이고 보안도 그러니까;; 쿠키 쓰는것임
    - 여기서 서버에서 셋쿠키통해서 사용자정보를 그대로 내려서 전달하는것도 보안상;;
    - 그래서 세션아이디를 보내는것. 세션아이디는 디비에 생성.
    - 쿠키에 세션정보가 잇는거다. 그러니 헤더에 세션정보를 서버에 담아보내자
    - 셋쿠키할때 만료정보를 넣을수잇다.
      - 영속쿠키:만료일까지, 세션쿠키:브라우저닫을때까지
    - 쿠키에 경로추가를하면 그경로포함 하위로만 쿠키접근가능
    - 쿠키옵션중에 secure옵션
      - 적용시 https인경우에만 쿠키전송을함
- 캐시..
  - 똑같은 데이터인데 계속 요청한다고해서 계속 받아옴;;
  - 뒤로가기해도 똑같은 요청해서 똒같이 기다려서 받는다생각해보셈 개느림
  - 서버에서 응답시 캐시컨트롤 : 유효시간 이렇게 적어서 보내면 됨
  - 그러면 브라우저의 캐시저장소에서 유효시간동안 쓸수잇음
  - 캐시가능시간동안 네트워크사용안해도됨 굳
  - 그러면 유효시간지나면 다시 네트워크타서 다 받아옴?
  - 이것도 좀 그런디; 똑같은건데
    - 여기서 검증헤더가 나온다.
    - 저장해둿던 유효기간이 지난 캐시를 재사용할수잇는방법이없나
    - 서버에서 응답할때 데이터의 최종 수정일까지 헤더에 담아주면
    - 이제 유효기간 지나고 클라이언트가 다시 똑가튼데이터 요청햇다치면(보낼때 헤더에 유효기간 캐시의 최종 수정일 담아보낸다) -이것이 조건부요청헤더
    - 서버에서는 만료일 검증후에 똑같은 데이터라면?
    - 304 not modified로 바디없이 빠르게 응답한다.
    - 그러면 뒤져잇던 캐시의 유효기간을 재갱신해서 사용한다.
      - 데이터 수정관련 검증헤더의 단점: 1초미만으로 캐시조정불가능, 데이터 수정햇지만 결과는 같은경우, ?
    - 데이터 수정관련 검증 헤더말고
      - Entity Tag 가 있다.
      - 캐시용 데이터에 임의의 버전이름을 달아서 전송.(보통 해쉬로.. 데이터같으면 해쉬값도 같다는걸이용)
      - 그래서 서버에서 Etag : 값을 보내고
      - 유효기간지난뒤에 클라가 요청할때 If-none-match : 유효기간지난캐시의etag값
      - 을 보낸다.
      - 서버에서는 ? 이제 매치가 되면 수정이 안된거니까 not modified 바디에 데이터없이 보낸다.
      - 캐시 유효기간 갱신해서 사용한다. 굳굳
  - 캐시 컨트롤 : 캐시의 유효시간
  - Cache-Control : no-cache > 데이터 캐시해도 되긴한데, 항상 서버에 검증하고 써라. (프록시서버(가짜서버)도 말고 원서버까지 가서 검증)
  - Cache-Control : no-store > 캐시하긴하는데 저장하진말고 메모리에서 잠깐사용
- 프록시캐시?
  - 한국에서 미국에있는 자원이진짜잇는 오리지널 서버까지 가는데는 넘오래걸린다
  - 한국어딘가에 미국 원서버와 연결된 프록시캐시서버가 있고, 우리는 거길 먼저 뒤진다.
  - 예를들면 유튜브... 미국원서버 >> 한국에서 누가봄? 그럼 한국프록시캐시서버에 잇으니까 내가 빨리볼수잇다. 이득ㅋㅋ
  - 그래서 아무도안보는 영상 내가 첨볼라하면 오래걸림
- 웹브라우저가 알아서 캐시하는경우가잇는데, 서버에서 그걸 원치않ㄴ는경우
  - 여러가지 헤더를 넣어야한다 ㅋㅋ.. 노캐시 노스토어 등등

