Chapter 3 - 스케쥴링 알고리즘

프로세스 process ?
- 실행 중인 프로그램 : 프로세스
- 메모리에 올려져서 실행 중인 프로그램
- 코드 이미지(바이너리) : 실행 파일, ex) ELF format

프로세스라는 용어는 작업, task, job 이라는 용어와 혼용하여 사용한다. (유사)

응용 프로그램 =! 프로세스 (같은 건 아님)
- 응용 프로그램은 여러 개의 프로세스로 이루어질 수 있음

하나의 응용 프로그램은 여러 개의 프로세스(프로그램)가 상호작용을 하면서 실행될 수도 있다.

프로세스가 통신하는 기법 : IPC 기법

스케쥴러와 프로세스
- 누가 프로세스 실행을 관리하는가? : 스케쥴러

스케쥴링 알고리즘 : 어느 순서대로 프로세스를 실행시킬까?
- 목표
-- 시분할 시스템의 예 : 프로세스 응답 시간을 가능한 짧게
-- 멀티 프로그래밍의 예 : CPU 활용도를 최대로 높혀서, 프로세스를 빨리 실행

'프로세스가 저장매체를 읽는 다든지, 프린팅을 한다든지 하는 작업 없이, 쭉 CPU를 처음부터 끝까지 사용한다'
는 가정하에 이해를 해보길 바람.
>>>

1. FIFO 스케쥴러
- 가장 간단한 스케쥴러 (배치 처리 시스템)
- FCFS (First Come First Served) 스케쥴러

2. 최단 작업 우선(SJF) 스케쥴러
- SJF(Shortest Job First) 스케쥴러
- 실행 시간을 다 알아야 가능한 알고리즘

# RealTime OS(RTOS) : 응용 프로그램 실시간 성능 보장을 목표로 하는 OS
- 정확하게 프로그램 시작, 완료 시간을 보장, 시간에 민감한 프로세스를 실행해야 하는 경우

# General Purpose OS(GPOS) : 프로세스 실행시간에 민감하지 않고, 일반적 목적으로 사용되는 OS

3. 우선순위 기반 스케쥴러
- Priority-Based 스케쥴러
- 정적 우선순위 : 프로세스마다 우선순위를 미리 지정
- 동적 우선순위 : 스케쥴러가 상황에 따라 우선순위를 동적으로 변경

4. Round Robin 스케쥴러
- 시분할 시스템 기반
- 일정 시간이 지나면 다음 프로세스 실행하고, 원래 실행중이던 프로세스는 대기열로 넘김

Chapter 3 - 프로세스 상태와 스케쥴링

멀티 프로그래밍과 Wait
- 멀티 프로그래밍 : CPU 활용도를 극대화 하는 스케쥴링 알고리즘
- Wait : 간단히 저장매체로부터 파일 읽기를 기다리는 시간으로 가정

ex) A 프로그램이 wait 일때 다른 프로그램을 run
이를 위해 프로세스 상태를 스케쥴러가 필요로 한다.

주요 프로세스 상태 
ready state : CPU에서 실행 가능 상태(실행 대기 상태)
block state(blocked blocking) : 특정 이벤트 발생 대기 상태 (wait 상태)(ex : 프린팅이 다 되었다.)
running state : 현재 CPU에서 실행 상태

프로세스 생성(생성 중이라 ready 전 상태) > (실행 가능 <-> 실행 중 >>> 대기 >>> 실행 가능) > 종료

ready 상태인 프로세스가 여러 개 일때 CPU는 어떤 프로세스를 골라야 할까?
>> 스케쥴링 알고리즘

선점형 스케쥴러 (Preemptive)
- 하나의 프로세스가 다른 프로세스 대신에 CPU를 차지할 수 있음

비선점형 스케쥴러 (Non-preemptive)
- 하나의 프로세스가 끝(block or end)나지 않으면 다른 프로세스는 CPU를 사용할 수 없음
- 프로세스가 자발적으로 blocking 상태로 들어가거나, 실행이 끝났을 때만, 다른 프로세스로 교체 가능

스케쥴러 구분 (정책, scheduling policy)
- FIFO(FCFS), SJF, Priority-based 은 어떤 프로세스를 먼저 실행시킬지에 대한 알고리즘 : 비선점형에 가깝다.
- RoundRobin 은 시분할 시스템을 위한 기본 알고리즘 : 선점형

스케쥴링 알고리즘의 조합
- 시분할
- 프로세스 상태 고려
- 정적 우선순위 기반
- 선점형

이런 방식으로 조합가능 > 응답시간 단축
