## 파일 시스템

- 파일 시스템: 운영체제가 저장매체에 파일을 쓰기 위한 자료구조 또는 알고리즘

### 가볍게 알아두기: 파일 시스템이 만들어진 이유 (블록) 

- 0과 1의 데이터를 어떻게 저장매체에 저장할까? 
  - 비트로 관리하기는 오버헤드가 너무 큼 
  - 블록 단위로 관리하기로 함 (보통 4KB) 
  - 블록마다 고유 번호를 부여해서, 관리

후;; 또 힘들어짐 저장매체가 늘어나니까

- 사용자가 각 블록 고유 번호를 관리하기 어려움 
  - 추상적(논리적) 객체 필요: 파일 
- 사용자는 파일단위로 관리 
  - 각 파일에는 블록 단위로 관리

### 저장매체 : 비트를 저장할 수 있는 주소가 있는 공간

![](.\img\46.png)

### 다양한 파일 시스템

- Windows: FAT, FAT32, NTFS 
  - 블록 위치를 FAT라는 자료 구조에 기록 
- 리눅스(UNIX): ext2, ext3, ext4 
  - 일종의 인덱스 블록 기법인 inode 방식 사용

![](.\img\47.png)

## inode 방식 파일 시스템

- 파일 시스템 기본 구조
  - 수퍼 블록: 파일 시스템 정보 및 파티션 정보 포함
  - 아이노드 블록: 파일 상세 정보 (PCB같은..)
  - 데이터 블록: 실제 데이터

### inode와 파일 

- 파일: inode 고유값과 자료구조에 의해 주요 정보 관리
  -  '파일이름:inode' 로 파일이름은 inode 번호와 매칭 
  - 파일 시스템에서는 inode를 기반으로 파일 엑세스 
  - inode 기반 메타 데이터 저장

![](.\img\48.png)

![](.\img\49.png)

- inode 기반 메타 데이터 ?
  - 파일권한, 소유자 정보, 파일 사이즈, 생성시간 등 시간 관련 정보, 데이터 저장 위치 등...
  - 이런 것들이 inode 블럭에 저장되어 있다.

![](.\img\50.png)

Direct Blocks : 12개 정도의 주소공간을 가진다.

이 주소들이 실제 데이터블럭의 주소를 가리킨다.

데이터 블럭의 사이즈 : 1KB ~ 4KB

아니 그럼 데이터 블럭 하나에 최대 4KB 정도인데 1기가 정도 되는 파일이면, Direct Block 주소 공간을 늘려버릴수도 없고;;

그래서 나온게 

Indirect Blocks, Double Indirect, Triple Indirect

![](.\img\51.png)

![](.\img\52.png)

디렉토리 엔트리 구조를 이용해서 해당 파일의 inode 번호를 얻게 된다.

![](.\img\53.png)

전통적인 유닉스 시스템에서는 모든 device 를 file처럼 다룬다 VFS를 이용해서!

### 리눅스(유닉스) 운영체제와 가상 파일 시스템 

- 모든 것은 파일이라는 철학을 따름 
  - 모든 인터렉션은 파일을 읽고, 쓰는 것처럼 이루어져있음 
  - 마우스, 키보드와 같은 모든 디바이스 관련된 기술도 파일과 같이 다루어짐 
  - 모든 자원에 대한 추상화 인터페이스로 파일 인터페이스를 활용

- 디바이스 

  - 블록 다바이스(Block Device) 

    : HDD, CD/DVD와 같이 블록 또는 섹터 등 정해진 단위로 데이터 전송, IO 송수신 속도가 높음

  - 캐릭터 디바이스(Character Device) 

    : 키보드, 마우스등 byte 단위 데이터 전송, IO 송수신 속도가 낮음